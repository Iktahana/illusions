# Illusions Project - AI Agent Rules
# ====================================
# Single source of truth for all AI assistants (Cursor, Claude, etc.)
# Last updated: 2026-02-06
#
# IMPORTANT: Documentation and code must use English or Japanese only.
# Communication with agents can use any language.

# ============================================================================
# üî¥ CRITICAL RULES - MUST FOLLOW (Non-negotiable)
# ============================================================================

## 1. Atomic Commit Strategy (MANDATORY - HIGHEST PRIORITY)
# ----------------------------------------------------------------------------
# ‚ö†Ô∏è THIS IS AS IMPORTANT AS THE LANGUAGE POLICY - ALWAYS ENFORCE

**YOU MUST follow the Atomic Commit principle for ALL git operations:**

### Core Principles
1. **One commit = One logical change** (single feature/fix/refactor)
2. **NEVER use `git add .`** - Always stage files individually by logical groups
3. **Use Conventional Commits format**: 
   - `feat:` - A new feature
   - `fix:` - A bug fix
   - `docs:` - Documentation only changes
   - `style:` - Code style changes (formatting, white-space, etc.)
   - `refactor:` - Code change that neither fixes a bug nor adds a feature
   - `perf:` - Performance improvement
   - `test:` - Adding or correcting tests
   - `chore:` - Build process or tooling changes

### Splitting Rules
- **Split unrelated changes**: If you modified both backend API and frontend UI, make separate commits
- **Before committing, ask yourself**: "Can this be broken into smaller independent parts?" If yes, DO IT.
- **Sequential dependencies**: If you refactor a function AND use it in a new feature:
  1. Commit the refactor first
  2. Then commit the feature

### Workflow for AI Agents
**Step 1**: Analyze all changes made
**Step 2**: Group changes by logical intent
**Step 3**: For each group:
  - Generate concise, imperative-style commit message
  - Example: `feat: add reading time calculation logic`
**Step 4**: Execute `git add <specific-files>` for each group
**Step 5**: Execute `git commit -m "<message>"` for each group

### Examples
- ‚ùå BAD: `git commit -m "fixed bug and updated styles"`
- ‚ùå BAD: `git add .`
- ‚úÖ GOOD: `git add src/utils/word-count.ts`
- ‚úÖ GOOD: `git commit -m "fix: resolve zero-division error in word count"`
- ‚úÖ GOOD (separate commit): `git add src/components/stats.css`
- ‚úÖ GOOD (separate commit): `git commit -m "style: adjust paragraph spacing in stats dashboard"`

### Granularity Guidelines
- **Too large**: One commit changes 10+ unrelated files across different features
- **Just right**: One commit adds a single feature/fix with its related files
- **Can be small**: One commit fixes a single typo in documentation

**If in doubt, create MORE commits rather than fewer.**

## 2. Branch & Directory Management (MANDATORY - CRITICAL)
# ----------------------------------------------------------------------------
# ‚ö†Ô∏è ALWAYS create separate branches and directories for new features

### Core Principles
1. **NEVER work directly in main branch for new features**
2. **ALWAYS create a feature branch** before starting work
3. **ALWAYS create a dedicated working directory** for the feature (if needed)
4. **Clean up after completion**: Merge to main, then delete branch and working directory

### Workflow for AI Agents

**Before Starting ANY New Feature:**
**Step 0**: Check for old working directories/branches
```bash
# Check for existing feature branches
git branch | grep -E "feature/|feat/|work/"

# Check for working directories
ls -la | grep -E "work-|feature-|temp-"
```

**If old directories/branches exist:**
- ‚ö†Ô∏è **STOP and ask user**: "I found existing working branches/directories: [list]. Should I delete them before starting?"
- Wait for user confirmation
- If yes: Clean up old branches and directories
- If no: Proceed with existing structure or create new ones

**Step 1**: Create feature branch
```bash
# Good branch naming
git checkout -b feature/reading-time-calculator
git checkout -b feat/storage-service-integration
git checkout -b fix/word-count-bug
```

**Step 2**: Create working directory (if applicable)
```bash
# For isolated features that need testing
mkdir work-reading-time/
cd work-reading-time/

# Or for prototypes
mkdir feature-new-editor/
cd feature-new-editor/
```

**Step 3**: Do your work
- Make atomic commits as usual
- Follow all other rules

**Step 4**: Complete and merge
```bash
# Merge to main
git checkout main
git merge feature/reading-time-calculator

# Delete feature branch
git branch -d feature/reading-time-calculator

# Delete working directory (if created)
cd ..
rm -rf work-reading-time/
```

### Examples

**‚ùå BAD - Working directly in main:**
```bash
# Currently on main branch
git add src/new-feature.ts
git commit -m "feat: add new feature"  # DON'T DO THIS ON MAIN!
```

**‚úÖ GOOD - Using feature branch:**
```bash
# Check for old branches first
git branch | grep feature/

# Create new branch
git checkout -b feature/auto-save
# ... do work ...
git add src/auto-save.ts
git commit -m "feat: add auto-save functionality"

# Merge and cleanup
git checkout main
git merge feature/auto-save
git branch -d feature/auto-save
```

**‚úÖ GOOD - With working directory:**
```bash
# Check for old working directories
ls -la | grep work-

# Create feature branch and directory
git checkout -b feature/new-ui
mkdir work-new-ui/
cd work-new-ui/
# ... do experimental work ...

# When ready, integrate to main source
cd ..
# Move finalized code to main source tree
# Commit on feature branch
git add src/components/NewUI.tsx
git commit -m "feat: add new UI component"

# Merge and cleanup
git checkout main
git merge feature/new-ui
git branch -d feature/new-ui
rm -rf work-new-ui/
```

### When to Create Working Directories
- ‚úÖ Experimental features that might fail
- ‚úÖ Prototypes that need isolated testing
- ‚úÖ Large refactoring that affects many files
- ‚úÖ New modules that aren't integrated yet
- ‚ùå Simple bug fixes (just use feature branch)
- ‚ùå Documentation updates (just use feature branch)

### Branch Naming Conventions
- `feature/` or `feat/` - New features
- `fix/` - Bug fixes
- `refactor/` - Code refactoring
- `docs/` - Documentation only
- `test/` - Test-related changes
- `chore/` - Maintenance tasks

### Critical Reminders
- **Always check for old branches/directories at start**
- **Always ask user before deleting old work**
- **Always clean up after merging to main**
- **Never leave orphaned branches or directories**

## 3. Language Standards (CRITICAL - STRICTLY ENFORCED)
# ----------------------------------------------------------------------------

### ‚ùå STRICTLY FORBIDDEN in Code/Documentation:
- **Chinese (‰∏≠Êñá/‰∏≠ÂõΩË™û)** - ABSOLUTELY PROHIBITED
- **Korean (ÌïúÍµ≠Ïñ¥/ÈüìÂõΩË™û)** - ABSOLUTELY PROHIBITED
- **Any other languages** except English and Japanese

### ‚úÖ ALLOWED Languages:
- **English**: Preferred for code logic (variables, functions, types, comments)
- **Japanese (Êó•Êú¨Ë™û)**: Required for UI strings, allowed for comments and user-facing documentation

### Where This Policy Applies (Code/Documentation):
- ‚úÖ Code logic: Variable names, function names, class names
- ‚úÖ Code comments: All inline comments and block comments in source files
- ‚úÖ Documentation files: README, API docs, technical specs
- ‚úÖ String literals: UI text, error messages, log messages
- ‚úÖ JSDoc: Function documentation and type annotations
- ‚úÖ Configuration: Config files, JSON data, YAML files
- ‚úÖ **Commit messages**: Git commit messages and PR descriptions (English or Japanese ONLY)

### ‚úÖ ALLOWED in AI Conversations & Planning:
- AI assistant responses (ÂèØ‰ª•Áî®‰∏≠ÊñáÂõûÂ§çÁî®Êà∑)
- Project planning documents
- Internal notes and discussions
- Design documents and specifications

### UI/UX Language Requirements:
- **ALL user-facing text MUST be in Japanese**
- This includes:
  - Menu items (macOS Application menu, File, Edit, View, Window, Help)
  - Dialog boxes and notifications
  - Buttons, labels, placeholders, tooltips
  - Error messages shown to users
  - Update notifications

### Standard UI Translations:
- File ‚Üí „Éï„Ç°„Ç§„É´
- Edit ‚Üí Á∑®ÈõÜ
- View ‚Üí Ë°®Á§∫
- Save ‚Üí ‰øùÂ≠ò
- Open ‚Üí Èñã„Åè
- Close ‚Üí Èñâ„Åò„Çã
- Quit ‚Üí „ÇíÁµÇ‰∫Ü
- Word Count ‚Üí ÊñáÂ≠óÊï∞
- Paragraph Count ‚Üí ÊÆµËêΩÊï∞
- Reading Time ‚Üí Ë™≠‰∫ÜÊôÇÈñì

# ============================================================================
# üü° HIGH PRIORITY RULES
# ============================================================================

## 4. TypeScript & Code Style Standards
# ----------------------------------------------------------------------------

### TypeScript Requirements
- **Strict Mode**: All files must work with TypeScript strict mode enabled
- **Type Safety**: Avoid `any` types unless absolutely necessary; prefer `unknown` or specific types
- **Type Imports**: Use `import type` for type-only imports
- **Explicit Return Types**: Public functions should have explicit return types

### Naming Conventions
- **Components/Classes**: PascalCase (e.g., `EditorComponent`, `StorageManager`)
- **Functions/Variables**: camelCase (e.g., `handleClick`, `isLoading`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `MAX_FILE_SIZE`, `DEFAULT_FONT_SIZE`)
- **Types/Interfaces**: PascalCase with descriptive names (e.g., `EditorProps`, `FileMetadata`)
- **Files**: 
  - kebab-case for utilities (e.g., `use-mdi-file.ts`)
  - PascalCase for components (e.g., `Editor.tsx`)

### Import Order
1. External libraries (React, Next.js, etc.)
2. Internal packages (@/)
3. Relative imports (./)
4. Types (import type)

### Code Organization
- **Comments**: Use JSDoc for public functions and complex logic
- **Component Structure**: Props interface ‚Üí Component ‚Üí Helper functions ‚Üí Exports
- **Early Returns**: Use early returns to reduce nesting

## 5. React Best Practices
# ----------------------------------------------------------------------------

### Component Standards
- **Functional Components**: Prefer function components over class components
- **Hooks Rules**: Follow React hooks rules (no conditional hooks, proper dependencies)
- **Event Handlers**: Name with `handle` prefix (e.g., `handleClick`, `handleChange`)
- **Props Destructuring**: Destructure props in function parameters for clarity

### Performance Optimization
- **Hooks Dependencies**: Verify `useEffect`, `useCallback`, `useMemo` dependency arrays are complete and correct
- **Unnecessary Re-renders**: Check for missing `React.memo`, `useCallback`, or `useMemo` optimizations
- **Memory Leaks**: 
  - Ensure event listeners are cleaned up in `useEffect` return functions
  - Check for proper subscription cleanup (IPC listeners, timers, observers)
- **Infinite Loops**: Detect potential infinite re-render cycles

## 6. Security Standards
# ----------------------------------------------------------------------------

### Critical Security Checks
- **Sensitive Data**: Never hardcode API keys, passwords, tokens, or credentials
- **Electron IPC Security**: 
  - Verify `contextIsolation: true` in preload configuration
  - Check `nodeIntegration: false` in BrowserWindow
  - Validate all IPC message handlers for input sanitization
  - Review `preload.js` for potential security vulnerabilities
- **XSS Prevention**: Check for unsafe DOM manipulation, `dangerouslySetInnerHTML`, or unescaped user input
- **Code Injection**: Detect use of `eval()`, `Function()`, or dynamic script execution
- **File System Access**: Ensure proper validation of file paths in Electron main process
- **External Dependencies**: Flag suspicious or unmaintained npm packages

# ============================================================================
# üü¢ PROJECT-SPECIFIC RULES
# ============================================================================

## 7. Storage Service (CRITICAL - ALWAYS USE)
# ----------------------------------------------------------------------------

### Storage Service is Mandatory
**DO NOT implement your own storage logic. ALWAYS use the unified StorageService.**

### Quick Start
```typescript
import { getStorageService } from "@/lib/storage-service";

const storage = getStorageService();

// Save session
await storage.saveSession({
  appState: { lastOpenedMdiPath: "/path/to/file.mdi" },
  recentFiles: [],
  editorBuffer: { content: "...", timestamp: Date.now() }
});

// Load session
const session = await storage.loadSession();
```

### 12 Core Methods
- **Session**: `saveSession()`, `loadSession()`
- **App State**: `saveAppState()`, `loadAppState()`
- **Recent Files**: `addToRecent()`, `getRecentFiles()`, `removeFromRecent()`, `clearRecent()`
- **Editor Buffer**: `saveEditorBuffer()`, `loadEditorBuffer()`, `clearEditorBuffer()`
- **Utility**: `clearAll()`

### Storage Locations
- **Electron**: SQLite at `~/Library/Application Support/Illusions/illusions-storage.db`
- **Web**: Browser IndexedDB via Dexie

### What NOT to Do
- ‚ùå Do NOT implement custom storage logic in each component
- ‚ùå Do NOT use localStorage directly for persistence in Electron
- ‚ùå Do NOT manually interact with IndexedDB
- ‚ùå Do NOT directly manage SQLite

### What to Do Instead
- ‚úÖ Always use `getStorageService()`
- ‚úÖ Use unified API for read/write
- ‚úÖ Let the service handle environment detection
- ‚úÖ Save editor buffer periodically (every 30 seconds)

### Common Patterns

**Pattern 1: Restore on Startup**
```typescript
useEffect(() => {
  const restore = async () => {
    const storage = getStorageService();
    const session = await storage.loadSession();
    
    if (session?.appState.lastOpenedMdiPath) {
      await openFile(session.appState.lastOpenedMdiPath);
    }
    
    if (session?.editorBuffer) {
      restoreContent(session.editorBuffer.content);
    }
  };
  
  void restore();
}, []);
```

**Pattern 2: Auto-save Editor Buffer**
```typescript
useEffect(() => {
  const interval = setInterval(async () => {
    await storage.saveEditorBuffer({
      content: editorContent,
      timestamp: Date.now(),
    });
  }, 30000); // Every 30 seconds
  
  return () => clearInterval(interval);
}, [editorContent]);
```

**Pattern 3: Update State on Save**
```typescript
async function saveFile(path: string, content: string) {
  const storage = getStorageService();
  
  // Save to filesystem...
  
  // Update recent files
  await storage.addToRecent({
    name: path.split("/").pop()!,
    path,
    lastModified: Date.now(),
    snippet: content.substring(0, 100),
  });
  
  // Update app state
  await storage.saveAppState({ lastOpenedMdiPath: path });
  
  // Clear draft buffer
  await storage.clearEditorBuffer();
}
```

### Documentation References
- Quick nav: `docs/STORAGE_INDEX.md`
- Integration: `docs/STORAGE_INTEGRATION.md`
- API reference: `docs/STORAGE_QUICK_REFERENCE.md`
- Architecture: `docs/STORAGE_ARCHITECTURE.md`
- Electron checklist: `docs/ELECTRON_INTEGRATION_CHECKLIST.md`
- Code examples: `lib/storage-service-examples.ts`

## 8. Electron-Specific Rules
# ----------------------------------------------------------------------------

### IPC Communication
- Use typed IPC channels defined in `types/electron.d.ts`
- Always validate input in IPC handlers
- Use `contextIsolation: true` and `nodeIntegration: false`

### File Operations
- Always use Electron's dialog API for file selection
- Validate file paths before filesystem operations

### Storage
- Use StorageService abstraction (`electron-storage.ts`)
- Do NOT use localStorage for persistence

## 9. Next.js-Specific Rules
# ----------------------------------------------------------------------------

### Component Types
- **Client Components**: Mark with `"use client"` when using browser APIs or React hooks
- **Server Components**: Default to server components when possible
- **Dynamic Imports**: Use Next.js dynamic imports for code splitting

## 10. Milkdown Plugin Development
# ----------------------------------------------------------------------------

### Plugin Structure
- Follow the established pattern in `packages/milkdown-plugin-japanese-novel/`
- Properly type ProseMirror schemas and plugins
- Use proper tokenization with kuromoji for Japanese text processing

### MDI Syntax
- When editing or generating `.mdi` content, follow the syntax rules defined in `MDI.md` at the repo root

## 11. Performance Standards
# ----------------------------------------------------------------------------

### General Performance
- **Heavy Computations**: Flag expensive operations that should be memoized or moved to workers
- **Large Bundle Size**: Check for unnecessary imports or large libraries
- **Database Operations**: Review IndexedDB (Dexie) queries for efficiency

# ============================================================================
# üîµ WORKFLOW & COLLABORATION RULES
# ============================================================================

## 12. Token Usage Optimization
# ----------------------------------------------------------------------------

### Read Files Selectively
- ‚ùå DO NOT read entire codebase or directory tree without specific need
- ‚úÖ Only read files that are directly relevant to the current task
- ‚úÖ Use `Grep` to search for specific patterns before reading files
- ‚úÖ Use `offset` and `limit` parameters when reading large files

### Tool Selection
- Prefer `Grep` over reading multiple files to find specific code
- Use `Glob` to find files by pattern, then selectively read
- Avoid using `Read` on generated files (dist/, out/, node_modules/, .next/)

### Context Management
- Only include necessary context in responses
- Avoid repeating unchanged code snippets
- Be concise in explanations unless user asks for details

## 13. Testing Standards (Future)
# ----------------------------------------------------------------------------

### Test Coverage
- **Unit Tests**: All utility functions should have unit tests
- **Component Tests**: Critical components should have integration tests
- **E2E Tests**: Main user flows should have E2E tests

# ============================================================================
# üìã REVIEW CHECKLIST
# ============================================================================

## Before Starting Work (Every Time!)
- [ ] **Check for old branches**: Run `git branch` to find feature branches
- [ ] **Check for old directories**: Run `ls -la` to find work-* or feature-* directories
- [ ] **Ask user if cleanup needed**: If old branches/directories exist, ask user before proceeding
- [ ] **Create feature branch**: Never work directly on main for new features

## Before Committing (Every Time!)
- [ ] **Working on feature branch**: Not committing directly to main
- [ ] **Atomic commits**: Did I split unrelated changes into separate commits?
- [ ] **Commit messages**: Did I use Conventional Commits format?
- [ ] **Language check**: Are all code/docs in English or Japanese only?
- [ ] **UI language**: Is all user-facing text in Japanese?
- [ ] **Security**: No hardcoded secrets or vulnerabilities?
- [ ] **Performance**: No memory leaks or unnecessary re-renders?
- [ ] **TypeScript**: All types properly defined?
- [ ] **Storage**: Using StorageService instead of custom logic?
- [ ] **React hooks**: Dependencies correct?
- [ ] **Code style**: Following naming conventions?

## After Completing Work (Every Time!)
- [ ] **Merge to main**: Merge feature branch to main
- [ ] **Delete feature branch**: Clean up merged branches
- [ ] **Delete working directory**: Remove temporary work directories
- [ ] **Verify cleanup**: No orphaned branches or directories left

## Priority Levels
1. **Critical (Must Fix)**: 
   - Working directly on main branch for new features
   - Atomic commit violations
   - Not checking for old branches/directories before starting
   - Security vulnerabilities
   - Language violations (Chinese/Korean in code)
   - Missing Japanese in UI

2. **High Priority**: 
   - Performance issues with user impact
   - Memory leaks
   - Type safety issues
   - Not using StorageService

3. **Medium Priority**: 
   - Code style inconsistencies
   - Missing optimizations

4. **Low Priority/Suggestions**: 
   - Japanese phrasing improvements
   - Minor refactoring opportunities

# ============================================================================
# üéØ QUICK REFERENCE
# ============================================================================

## Most Common Mistakes to Avoid
1. ‚ùå Working directly on main branch for new features
2. ‚ùå Not checking for old branches/directories before starting
3. ‚ùå Not cleaning up branches/directories after merging
4. ‚ùå Using `git add .` instead of staging files individually
5. ‚ùå Grouping unrelated changes into one commit
6. ‚ùå Using Chinese/Korean in code, comments, or commit messages
7. ‚ùå Not translating UI text to Japanese
8. ‚ùå Implementing custom storage logic instead of using StorageService
9. ‚ùå Using `any` type in TypeScript
10. ‚ùå Forgetting to clean up event listeners in `useEffect`
11. ‚ùå Missing dependency arrays in React hooks

## File Locations for Reference
- Code review standards: `CLAUDE.md`
- Quick guide: `AI_RULES_GUIDE.md`
- Storage documentation: `docs/STORAGE_INDEX.md`
- Electron integration: `docs/ELECTRON_INTEGRATION_CHECKLIST.md`

## Quick Commands Reference
```bash
# Check for old branches
git branch | grep -E "feature/|feat/|work/"

# Check for old working directories  
ls -la | grep -E "work-|feature-|temp-"

# Create feature branch
git checkout -b feature/my-feature

# Good commit workflow
git add src/specific-file.ts
git commit -m "feat: add specific feature"

# Merge and cleanup
git checkout main
git merge feature/my-feature
git branch -d feature/my-feature

# Check language compliance
grep -r "[\u4e00-\u9fff]" src/  # Chinese check
grep -r "[\uac00-\ud7af]" src/  # Korean check
```

---

**Version**: 2.1.0  
**Last Updated**: 2026-02-06  
**Status**: ‚úÖ Production - All AI agents must follow these rules
**Changes in 2.1.0**:
- Added Branch & Directory Management rule (CRITICAL)
- Added pre-work checklist for old branches/directories
- Added cleanup requirements after merge
- Clarified language policy in header
