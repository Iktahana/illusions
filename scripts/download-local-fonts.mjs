import { mkdir, readFile, stat, writeFile } from 'node:fs/promises';
import path from 'node:path';
import { createHash } from 'node:crypto';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const repoRoot = path.resolve(__dirname, '..');

const fonts = [
  { family: 'Noto Serif JP', weights: [400, 700] },
  { family: 'Noto Sans JP', weights: [400, 700] },
  { family: 'Shippori Mincho', weights: [400, 700] },
  { family: 'Zen Kaku Gothic New', weights: [400, 700] },
  { family: 'M PLUS Rounded 1c', weights: [400, 700] },
  { family: 'Fira Code', weights: [400, 700] },
];

const userAgent =
  'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:121.0) Gecko/20100101 Firefox/121.0';

function slugifyFontFamily(family) {
  return family
    .toLowerCase()
    .replace(/['"]/g, '')
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');
}

function familyToGoogleParam(family) {
  return family.trim().replace(/\s+/g, '+');
}

function hashUrl(url) {
  return createHash('sha1').update(url).digest('hex').slice(0, 12);
}

async function fileExists(filePath) {
  try {
    await stat(filePath);
    return true;
  } catch {
    return false;
  }
}

async function fetchGoogleCss({ family, weights }) {
  const familyParam = familyToGoogleParam(family);
  const weightParam = weights.join(';');
  const url = `https://fonts.googleapis.com/css2?family=${familyParam}:wght@${weightParam}&display=swap`;

  const res = await fetch(url, {
    headers: {
      'User-Agent': userAgent,
    },
  });

  if (!res.ok) {
    throw new Error(`Failed to fetch CSS for "${family}" (${res.status} ${res.statusText})`);
  }

  return await res.text();
}

function extractWoff2Urls(cssText) {
  const urls = new Set();
  const re =
    /url\((['"]?)(https:\/\/fonts\.gstatic\.com\/[^)'"]+)\1\)\s*format\(['"]woff2['"]\)/g;
  let match;
  while ((match = re.exec(cssText)) !== null) {
    urls.add(match[2]);
  }
  return [...urls];
}

async function downloadToFile(url, filePath) {
  const res = await fetch(url, { headers: { 'User-Agent': userAgent } });
  if (!res.ok) {
    throw new Error(`Failed to download ${url} (${res.status} ${res.statusText})`);
  }
  const arrayBuffer = await res.arrayBuffer();
  await writeFile(filePath, Buffer.from(arrayBuffer));
}

async function main() {
  const publicFontsDir = path.join(repoRoot, 'public', 'fonts');
  const appCssPath = path.join(repoRoot, 'app', 'local-fonts.css');

  await mkdir(publicFontsDir, { recursive: true });

  let combinedCss = '';

  for (const font of fonts) {
    const slug = slugifyFontFamily(font.family);
    const fontDir = path.join(publicFontsDir, slug);
    await mkdir(fontDir, { recursive: true });

    const cssText = await fetchGoogleCss(font);
    const urls = extractWoff2Urls(cssText);

    const replacements = new Map();
    for (const url of urls) {
      const filename = `${hashUrl(url)}.woff2`;
      const outPath = path.join(fontDir, filename);

      if (!(await fileExists(outPath))) {
        await downloadToFile(url, outPath);
      }

      replacements.set(url, `/fonts/${slug}/${filename}`);
    }

    let rewritten = cssText;
    for (const [from, to] of replacements) {
      rewritten = rewritten.split(from).join(to);
    }

    combinedCss += `/* ${font.family} (local) */\n${rewritten.trim()}\n\n`;
  }

  const header = `/*
 * Auto-generated by scripts/download-local-fonts.mjs
 *
 * Source: Google Fonts CSS (woff2) rewritten to local /public/fonts paths.
 */

`;

  await writeFile(appCssPath, header + combinedCss.trimEnd() + '\n');

  const written = await readFile(appCssPath, 'utf8');
  if (!written.includes('@font-face')) {
    throw new Error(
      `Generated ${path.relative(repoRoot, appCssPath)} does not include @font-face`
    );
  }

  // eslint-disable-next-line no-console
  console.log(
    `Wrote ${path.relative(repoRoot, appCssPath)} and downloaded fonts into public/fonts/`
  );
}

main().catch((err) => {
  // eslint-disable-next-line no-console
  console.error(err);
  process.exit(1);
});
